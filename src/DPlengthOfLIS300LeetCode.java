import java.util.Arrays;

/**
 * 给定一个无序的整数数组，找到其中最长上升子序列的长度。
 * 示例:
 * 输入: [10,9,2,5,3,7,101,18]
 * 输出: 4
 * 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
 * 说明:
 * 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
 * 你算法的时间复杂度应该为 O(n2) 。
 * 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
 * 思路：动态规划，这题的状态转移方程比较难写。
 * 参考：https://leetcode-cn.com/problems/longest-increasing-subsequence/
 * solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
 * @author LemonLin
 * @Description :DPlengthOfLIS300LeetCode
 * @date 20.1.30-20:24
 * 这题的难点是这个双循环为什么要这么写，同时状态转移方程为什么是这样写的。
 * 首先说一下这个双循环，和一般的回溯搜索循环不一样，回溯搜索循环的双循环是：
 *  for (int i=0;i<nums.length;i++){
 *             for (int j=i;j<nums.length;j++){
 * 这样的写法是，前面的坐标用了，就不能再用了。比如[10,9,2,5,3,7,101,18]
 * i=0时：循环遍历：[10,9,2,5,3,7,101,18]
 * i=1时：循环遍历：[9,2,5,3,7,101,18]
 * i=2时，循环遍历：[2,5,3,7,101,18]
 * 以此类推
 * 本题看清楚是求的醉成子序列，那么她的循环遍历过程是这样的：
 * i=0时：循环遍历：[10]
 * i=1时：循环遍历：[10,9]
 * i=2时，循环遍历：[10,9,2]
 * 以此类推。
 * 所以双循环的写法是：
*  for (int i=0;i<nums.length;i++){
 *        for (int j=0;j<i;j++){
 * 第二说一下状态转移方程为什么是这样写：搞清楚了上述循环的情况，因为dp[i]是要求
 * 在无序数组中最长的上升子序列，上升是通过if (nums[j]<nums[i]){这个判断来控制的，
 * 最长怎么控制，就是不断的赋值来控制：举个例子：
 * 当i=6时，求dp[6],求法是固定i,进入内循环，变化j,j从0--5，因为是无序的，所以很可
 * 能j=4时的dp[5]大于j=3时的dp[5]，因为求dp[5],是求当j=0,j=1,j=2...j=4每个状态
 * 下的dp[5]的最大值。所以每次都需要重新比较旧的dp[i]和新的dp[i](也就是dp[j]+1)谁
 * 更大，谁更大就作为新的dp[i],这就推出了状态转移方程是：
 *                  if (nums[j]<nums[i]){
 *                     dp[i]=Math.max(dp[i],dp[j]+1);
 *                 }
 *   同时从本题要注意解决DP问题的步骤：
 *   第一：想暴力：通常用递归思路；
 *   第二：迅速想一下怎么记忆化搜索
 *   第三：根据前面两点的公式推出DP的解法。
 *   有时，第一第二不好想出来，也可以尝试也许直接想第三比较简单。
 *   直接DP的如下五个步骤：
 *   第 1 步：定义状态。首先考虑“题目问什么，就把什么定义成状态”，发现无从下手。但
 *   可以基于下面这个事实，考虑状态的定义：
 * 为了从一个较短的上升子序列得到一个较长的上升子序列，我们主要关心这个较短的上升
 * 子序列结尾的元素。
 * 为了保证子序列的相对顺序性，在程序读到一个新的数的时候，如果比已经得到的子序列
 * 的最后一个数还大，那么就可以放在这个子序列的最后，形成一个更长的子序列。
 * 一个子序列一定会以一个数结尾，于是将状态定义成：dp[i] 表示以 nums[i] 结尾的“
 * 最长上升子序列”的长度，注意这个定义中 nums[i] 必须被选取，且必须被放在最后一个元素。
 * 第 2 步：考虑状态转移方程；
 * 遍历到 nums[i] 时，考虑把索引 i 之前的所有的数都看一遍，只要当前的数 nums[i]
 * 严格大于之前的某个数，那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序
 * 列。因此，dp[i] 就等于索引 i 之前严格小于 nums[i] 的状态最大者 +1。
 * 语言描述：在索引 i 之前严格小于 nums[i] 的所有状态中的最大者 + 1
 * 第 3 步：考虑初始化：dp[0] = 1，1 个字符当然也是长度为 1 的上升子序列；
 * 第 4 步：考虑输出：所有 dp[i] 中的最大值（dp[i] 考虑了所有以 nums[i] 结尾的上升子序列）；
 * 第 5 步：考虑状态压缩：之前所有的状态都得保留，因此无法压缩。
 */
public class DPlengthOfLIS300LeetCode {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        //dp数组要初始化为1，因为之后要用到默认的dp[i]进行比较
        Arrays.fill(dp,1);
        for (int i=0;i<nums.length;i++){
            for (int j=0;j<i;j++){
                if (nums[j]<nums[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
        }
        //求完所有的DP之后遍历寻找出最大的dp值即可。
        int result =0;
        for (int k=0;k<dp.length;k++){
            if (dp[k]>result){
                result = dp[k];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int [] nums = {};
        System.out.println(new DPlengthOfLIS300LeetCode().lengthOfLIS(nums));
    }
}
